#pragma kernel WaterIncrement
#pragma kernel OutflowCalculation
#pragma kernel VelocityFieldCalculation
#pragma kernel ErosionAndDeposition
#pragma kernel SedimentTransport
#pragma kernel Evaporation

cbuffer Params
{
    int width;
    int height;
    float cellSize;

    float rainfall;

    float gravity; // 9.81
    float deltaTime;

    float minSlope; // 0.01..0.03

    float capacityFactor; // 4..12
    float erodeSpeed; // 0.4..1.0
    float depositSpeed; // 0.3..0.8
    
    float evaporation;
}

RWTexture2D<float> HeightMap;
RWTexture2D<float> WaterMap;
RWTexture2D<float> SedimentMap;
RWTexture2D<float4> OutflowMap;
RWTexture2D<float2> VelocityMap;

RWTexture2D<float> TempHeightMap;
RWTexture2D<float> TempWaterMap;
RWTexture2D<float> TempSedimentMap;
RWTexture2D<float> TempOutflowMap;

#include "math.hlsl"

inline float GetTotalHeight(int2 pixel)
{
    return HeightMap[pixel] + WaterMap[pixel];
}

float CalculateDeltaH(int2 pixel, int2 neighborPixel)
{
    return GetTotalHeight(pixel) - GetTotalHeight(neighborPixel);
}

float CalculateOutflowToNeighbor(int2 pixel, int2 neighborPixel, float previousOutflow)
{
    return (neighborPixel.x < 0 || neighborPixel.x >= width || neighborPixel.y < 0 || neighborPixel.y >= height) ?
        .0f :
        max(.0f, previousOutflow + deltaTime * gravity * CalculateDeltaH(pixel, neighborPixel));
}

float4 GetSafeOutflow(int2 pixel)
{
    return (pixel.x < 0 || pixel.x >= width || pixel.y < 0 || pixel.y >= height) ?
        0 :
        OutflowMap[pixel];
}

inline float SedimentLiminiting(float water, float maxErosion)
{
    return water <= 0 ? 0 : water < maxErosion ? 1 - (maxErosion - water) / maxErosion : 1;
}

[numthreads(8, 8, 1)]
void WaterIncrement(uint3 id : SV_DispatchThreadID)
{
    int2 p = int2(id.xy);

    if (p.x >= width || p.y >= height)
        return;
    
    float water = WaterMap[p];
    
    TempWaterMap[p] = water + rainfall * deltaTime;
}

[numthreads(8, 8, 1)]
void OutflowCalculation(uint3 id : SV_DispatchThreadID)
{
    int2 p = int2(id.xy);
    
    float water = WaterMap[p];
    
    int2 L = int2(p.x - 1, p.y);
    int2 R = int2(p.x + 1, p.y);
    int2 U = int2(p.x, p.y + 1);
    int2 D = int2(p.x, p.y - 1);
    
    float prevL = GetSafeOutflow(L).g;
    float prevR = GetSafeOutflow(R).r;
    float prevU = GetSafeOutflow(U).a;
    float prevD = GetSafeOutflow(D).b;
    
    float4 outflow = float4(CalculateOutflowToNeighbor(p, L, prevL),
                            CalculateOutflowToNeighbor(p, R, prevR),
                            CalculateOutflowToNeighbor(p, U, prevU),
                            CalculateOutflowToNeighbor(p, D, prevD));

    float outflowDeltaSum = VectorContractionByOne(outflow);

    outflow *= outflowDeltaSum > water ? min(.1, water / (outflowDeltaSum)) : 1;
    
    TempOutflowMap[p] = outflow;
}

[numthreads(8, 8, 1)]
void VelocityFieldCalculation(uint3 id : SV_DispatchThreadID)
{
    int2 p = int2(id.xy);
    
    if (p.x >= width || p.y >= height)
        return;
    
    int2 L = int2(p.x - 1, p.y);
    int2 R = int2(p.x + 1, p.y);
    int2 U = int2(p.x, p.y + 1);
    int2 D = int2(p.x, p.y - 1);

    float4 inflow = float4(GetSafeOutflow(L).g, GetSafeOutflow(R).r, GetSafeOutflow(U).a, GetSafeOutflow(D).b);
    float4 outflow = OutflowMap[p];
    
    float inflowSum = VectorContractionByOne(inflow);
    float outflowSum = VectorContractionByOne(outflow);
    
    float waterDelta = (inflowSum - outflowSum) * deltaTime;

    float water = WaterMap[p];
    float newWater = water + waterDelta;
    float waterAvg = (water + newWater) * .5;
    
    float deltaWaterFlowX = (inflow.r - outflow.r + outflow.g - inflow.g) * .5;
    float deltaWaterFLowY = (inflow.a - outflow.a + outflow.b - inflow.b) * .5;
    
    float2 velocity = float2(deltaWaterFlowX, deltaWaterFLowY);
    
    VelocityMap[p] = velocity;
    TempWaterMap[p] = newWater;
}

[numthreads(8, 8, 1)]
void ErosionAndDeposition(uint3 id : SV_DispatchThreadID)
{
    int2 p = int2(id.xy);

    if (p.x >= width || p.y >= height)
        return;
    
    float h = HeightMap[p];
    float2 velocity = VelocityMap[p];
    float sediment = SedimentMap[p];
    float water = WaterMap[p];
    
    float2 heightDerivative = CalculateTextureDerivative(HeightMap, p, 1, 1);
    
    
    // Physics derivative based calculation (idk why its bugging...)
    
    //float3 normal = normalize((-heightDerivative.x, 1, -heightDerivative.y));
    //
    //float velocityLength = length(velocity);
    //
    //float velocity3d = (velocity.x, 0, velocity.y);
    //
    //float3 flowVector = normalize((velocity.x, dot(velocity, heightDerivative), velocity.y));   
    //
    //float cosTerm = max(.0, dot(normal, flowVector));
    //
    //float slope = max(minSlope, cosTerm);
    //
    //float capacity = capacityFactor * slope * velocityLength * SedimentLiminiting(water, 10);
    
    float sinAlpha = clamp(SinSlope(p, heightDerivative), 0, 1);
    
    float capacity = capacityFactor * sinAlpha * length(velocity);

    float newHeight;
    float newSediment;
    float newWater = WaterMap[p];
    
    if (capacity >= sediment)
    {
        float erosionDelta = (capacity - sediment) * erodeSpeed * deltaTime;
        newHeight = h - erosionDelta;
        newSediment = sediment + erosionDelta;
        newWater = water + erosionDelta;
    }
    else
    {
        float depositDelta = (sediment - capacity) * depositSpeed * deltaTime;
        newHeight = h + depositDelta;
        newSediment = sediment - depositDelta;
        newWater = water - depositDelta;
    }
    
    TempSedimentMap[p] = newSediment;
    TempHeightMap[p] = max(0, newHeight);
    TempWaterMap[p] = newWater;
}

[numthreads(8, 8, 1)]
void SedimentTransport(uint3 id : SV_DispatchThreadID)
{
    int2 p = int2(id.xy);

    if (p.x >= width || p.y >= height)
        return;

    int2 texSize = int2(width, height);
    
    float2 vel = VelocityMap[p];
    
    float2 src = p - vel * deltaTime;
    
    float newSediment = SampleBilinear(SedimentMap, src / texSize, texSize);   
    
    TempSedimentMap[p] = newSediment;
}

[numthreads(8, 8, 1)]
void Evaporation(uint3 id : SV_DispatchThreadID)
{
    int2 p = int2(id.xy);

    if (p.x >= width || p.y >= height)
        return;
    
    float water = WaterMap[p];

    TempWaterMap[p] = water * (1 - evaporation * deltaTime);
}