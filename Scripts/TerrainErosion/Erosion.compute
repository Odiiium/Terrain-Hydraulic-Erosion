#pragma kernel WaterIncrement
#pragma kernel OutflowCalculation
#pragma kernel VelocityFieldCalculation
#pragma kernel ErosionAndDeposition
#pragma kernel SedimentTransport
#pragma kernel Evaporation

cbuffer Params
{
    int width;
    int height;
    float cellSize;

    float rainfall;

    float gravity; // 9.81
    float deltaTime;

    float minSlope; // 0.01..0.03

    float capacityFactor; // 4..12
    float erodeSpeed; // 0.4..1.0
    float depositSpeed; // 0.3..0.8
    
    float evaporation;
}

RWTexture2D<float> HeightMap;
RWTexture2D<float> WaterMap;
RWTexture2D<float> SedimentMap;

RWTexture2D<float2> VelocityMap;

RWTexture2D<float4> OutflowMap;


inline float GetTotalHeight(int2 pixel)
{
    return HeightMap[pixel] + WaterMap[pixel];
}

float CalculateDeltaH(int2 pixel, int2 neighborPixel)
{
    return GetTotalHeight(pixel) - GetTotalHeight(neighborPixel);
}

float CalculateOutflowToNeighbor(int2 pixel, int2 neighborPixel, float previousOutflow)
{
    return (neighborPixel.x < 0 || neighborPixel.x >= width || neighborPixel.y < 0 || neighborPixel.y >= height) ?
        0 :
        max(0, previousOutflow + deltaTime * gravity * CalculateDeltaH(pixel, neighborPixel));
}

float4 GetSafeOutflow(int2 pixel)
{
    return (pixel.x < 0 || pixel.x >= width || pixel.y < 0 || pixel.y >= height) ?
        0 :
        OutflowMap[pixel];
}

float VectorContractionByOne(float4 vec)
{
    return dot(vec, float4(1, 1, 1, 1));
}

int clampInt(int v, int a, int b)
{
    return max(a, min(v, b));
}

float SampleBilinear(RWTexture2D<float> tex, float2 srcUV, int2 texSize)
{
    float2 pos = srcUV * (float2)texSize - 0.5;

    int2 iPos = int2(floor(pos));
    float2 f = pos - (float2) iPos;

    int2 i00 = int2(clampInt(iPos.x, 0, texSize.x - 1), clampInt(iPos.y, 0, texSize.y - 1));
    int2 i10 = int2(clampInt(iPos.x + 1, 0, texSize.x - 1), clampInt(iPos.y, 0, texSize.y - 1));
    int2 i01 = int2(clampInt(iPos.x, 0, texSize.x - 1), clampInt(iPos.y + 1, 0, texSize.y - 1));
    int2 i11 = int2(clampInt(iPos.x + 1, 0, texSize.x - 1), clampInt(iPos.y + 1, 0, texSize.y - 1));

    float v00 = tex.Load(int3(i00, 0));
    float v10 = tex.Load(int3(i10, 0));
    float v01 = tex.Load(int3(i01, 0));
    float v11 = tex.Load(int3(i11, 0));

    float vx0 = lerp(v00, v10, f.x);
    float vx1 = lerp(v01, v11, f.x);
    float vxy = lerp(vx0, vx1, f.y);

    return vxy;
}

[numthreads(8, 8, 1)]
void WaterIncrement(uint3 id : SV_DispatchThreadID)
{
    int2 p = int2(id.xy);

    if (p.x >= width || p.y >= height)
        return;
    
    WaterMap[p] += rainfall * deltaTime;    
}

[numthreads(8, 8, 1)]
void OutflowCalculation(uint3 id : SV_DispatchThreadID)
{
    int2 p = int2(id.xy);

    if (p.x >= width || p.y >= height)
        return;
    
    int2 L = int2(p.x - 1, p.y);
    int2 R = int2(p.x + 1, p.y);
    int2 U = int2(p.x, p.y + 1);
    int2 D = int2(p.x, p.y - 1);
    
    float4 outflow = float4(CalculateOutflowToNeighbor(p, L, OutflowMap[p].r),
                            CalculateOutflowToNeighbor(p, R, OutflowMap[p].g),
                            CalculateOutflowToNeighbor(p, U, OutflowMap[p].b),
                            CalculateOutflowToNeighbor(p, D, OutflowMap[p].a));

    float outflowDeltaSum = VectorContractionByOne(outflow) * deltaTime;
    float scalingFactor = min(1, WaterMap[p] / outflowDeltaSum);
    
    outflow *= scalingFactor;
    
    OutflowMap[p] = outflow;
}

[numthreads(8, 8, 1)]
void VelocityFieldCalculation(uint3 id : SV_DispatchThreadID)
{
    int2 p = int2(id.xy);

    if (p.x >= width || p.y >= height)
        return;
    
    int2 L = int2(p.x - 1, p.y);
    int2 R = int2(p.x + 1, p.y);
    int2 U = int2(p.x, p.y + 1);
    int2 D = int2(p.x, p.y - 1);

    float4 inflow = float4(GetSafeOutflow(L).g, GetSafeOutflow(R).r, GetSafeOutflow(U).a, GetSafeOutflow(D).b);
    float4 outflow = OutflowMap[p];
    
    float inflowSum = VectorContractionByOne(inflow);
    float outflowSum = VectorContractionByOne(outflow);
    
    float deltaVelocity = deltaTime * (inflowSum - outflowSum);

    float water = WaterMap[p];
    float newWater = water + deltaVelocity;
    float waterAvg = (water + newWater) * .5;
    
    float deltaWaterFlowX = (inflow.r - outflow.r + outflow.g - inflow.g) * .5;
    float deltaWaterFLowY = (inflow.a - outflow.a + outflow.b - inflow.b) * .5;
    
    float2 velocity = float2(deltaWaterFlowX, deltaWaterFLowY) * deltaTime;

    VelocityMap[p] = velocity;
    WaterMap[p] = newWater;
}

[numthreads(8, 8, 1)]
void ErosionAndDeposition(uint3 id : SV_DispatchThreadID)
{
    int2 p = int2(id.xy);

    if (p.x >= width || p.y >= height)
        return;
    
    float h = HeightMap[p];
    float2 velocity = VelocityMap[p];
    float sediment = SedimentMap[p];
    
    float hL = HeightMap[float2(p.x > 0 ? p.x - 1 : p.x, p.y)];
    float hR = HeightMap[float2(p.x + 1 < width ? p.x + 1 : p.x, p.y)];
    float hU = HeightMap[float2(p.x, p.y + 1 < height ? p.y + 1 : p.y)];
    float hD = HeightMap[float2(p.x, p.y > 0 ? p.y - 1 : p.y)];

    float dhdx = (hR - hL) * 0.5;
    float dhdy = (hU - hD) * 0.5;

    //float2 dhdp = float2(dhdx, dhdy);

    float slope = sqrt(dhdx * dhdx + dhdy * dhdy);
    slope = max(slope, minSlope);

    float sinAlpha = slope / sqrt(1 + slope * slope);
    
    float capacity = capacityFactor * sinAlpha * length(velocity);

    float newHeight;
    float newSediment;
    
    if (capacity > sediment)
    {
        float erosionDelta = (capacity - sediment) * erodeSpeed;
        newHeight = h - erosionDelta;
        newSediment = sediment + erosionDelta;
    }
    else
    {
        float depositDelta = (sediment - capacity) * depositSpeed;
        newHeight = h + depositDelta;
        newSediment = sediment - depositDelta;
    }
    
    SedimentMap[p] = newSediment;
    
    int2 texSize = int2(width, height);

    float2 src = p - velocity * deltaTime;
    
    float2 srcUV = src / texSize;
    
    float sed = SampleBilinear(SedimentMap, srcUV, texSize);
    
    SedimentMap[p] = sed;
    HeightMap[p] = max(0, newHeight);
}

[numthreads(8, 8, 1)]
void SedimentTransport(uint3 id : SV_DispatchThreadID)
{
    int2 p = int2(id.xy);

    if (p.x >= width || p.y >= height)
        return;

    //int2 texSize = int2(width, height);
    //
    //float2 vel = VelocityMap[p];
    //
    //float2 src = p - vel * deltaTime;
    //
    //float2 srcUV = src / texSize;
    //
    //float newSediment = SampleBilinear(SedimentMap, srcUV, texSize);
    //
    //SedimentMap[p] = newSediment;
}

[numthreads(8, 8, 1)]
void Evaporation(uint3 id : SV_DispatchThreadID)
{
    int2 p = int2(id.xy);

    if (p.x >= width || p.y >= height)
        return;
    
    float water = WaterMap[p];
    
    float evaporateFactor = (1 - evaporation * deltaTime);
    
    WaterMap[p] = water * evaporateFactor;
}